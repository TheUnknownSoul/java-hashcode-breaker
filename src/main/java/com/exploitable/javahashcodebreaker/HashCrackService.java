package com.exploitable.javahashcodebreaker;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.springframework.stereotype.Service;


import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Scanner;


@Service
@Slf4j
@RequiredArgsConstructor
public class HashCrackService {
    private final Options options;
    private final CommandLineParser commandLineParser;
    private final HelpFormatter helpFormatter;


    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_RESET = "\u001B[0m";


    public void crackTheHash(String[] args) {
        String hashToCrack = getHashOption(args);
        String wordlist = getWordlistOption(args);
        boolean verbose = hasVerboseOption(args);
        log.info("Starting cracking ....");
        try {
            Path path = Path.of(wordlist);
            if (!verbose) {
                try (Scanner scanner = new Scanner(new FileReader(path.toFile()))) {
                    while (scanner.hasNextLine()) {
                        String line = scanner.next();
                        if (line != null) {
                            int possibleHash = line.hashCode();

                            if (possibleHash == Integer.parseInt(hashToCrack)) {
                                log.info("Found. Hashed text is: " + ANSI_GREEN + line + " " + ANSI_RESET + " which equal to hash "
                                        + possibleHash + " in provided option.");
                                return;
                            }
                        }
                    }
                    log.warn("Hash candidates not found.");
                }
            } else {
                try (Scanner reader = new Scanner(new FileReader(path.toFile()))) {
                    while (reader.hasNextLine()) {
                        String line = reader.next();
                        if (line != null) {
                            int possibleHash = line.hashCode();
                            log.info(line);
                            if (possibleHash == Integer.parseInt(hashToCrack)) {
                                log.info("Found. Hashed text is: " + ANSI_GREEN + line + " " + ANSI_RESET + " which equal to hash "
                                        + possibleHash + " in provided option.");
                                return;
                            }
                        }
                    }
                    log.warn("Hash candidates not found.");
                }
            }
        } catch (IOException e) {
            log.error("File not found. Check the file path " + e.getMessage());
        }
    }

    private boolean isOptionsValid(String[] args) {
        try {
            CommandLine parse = commandLineParser.parse(options, args);
            String hashToCrackShortOption = parse.getOptionValue("h");
            String hashToCrackLongOption = parse.getOptionValue("hash");
            String wordlistShort = parse.getOptionValue("w");
            String wordlistLong = parse.getOptionValue("wordlist");
            Path pathToWordlist = Path.of(wordlistLong);
            Path path = Path.of(wordlistShort);
            boolean isHashValid = (!hashToCrackShortOption.trim().isBlank() || !hashToCrackLongOption.trim().isBlank());
            boolean isWordlistValid = (!wordlistShort.trim().isBlank() || !wordlistLong.trim().isBlank());
            boolean isPathToWordlistValid = (!pathToWordlist.toString().trim().isBlank() || !path.toString().trim().isBlank());
            if (isHashValid && isWordlistValid && isPathToWordlistValid) {
                return true;
            } else {
                throw new ParseException(" ");
            }
        } catch (ParseException parseException) {
            log.error("Couldn't parse provided options." + parseException.getMessage());
            helpFormatter.printHelp("please use the options below", options);
            System.exit(1);
        }
        return false;
    }

    private boolean isOptionsParses(String[] args) {
        try {
            CommandLine parse = commandLineParser.parse(options, args);
//          check short variant of options, then long, then both if they contain verbosity
            if (parse.hasOption("h") && parse.hasOption("w") ||
                    parse.hasOption("hash") && parse.hasOption("wordlist") ||
                    parse.hasOption("h") && parse.hasOption("w") && parse.hasOption("v") ||
                    parse.hasOption("hash") && parse.hasOption("wordlist") && parse.hasOption("v")) {
                return true;
            }
        } catch (ParseException parseException) {
            helpFormatter.printHelp("please use the options below", options);
            log.error("Couldn't parse provided options or something went wrong" + parseException.getMessage());
            System.exit(1);
        }
        return false;
    }

    private String getHashOption(String[] args) {
        String hash = null;
        try {
            CommandLine parse = commandLineParser.parse(options, args);
            if (isOptionsOk(args) && parse.hasOption("hash")) {
                hash =  parse.getOptionValue("hash");
            }
            hash = parse.getOptionValue('h');
        } catch (ParseException parseException) {
            log.error("Couldn't parse provided hash value or hash is empty" + parseException.getMessage());
            System.exit(1);
        }
        return hash;
    }

    private String getWordlistOption(String[] args) {
        String wordlist = null;
        try {
            CommandLine parse = commandLineParser.parse(options, args);
            if (isOptionsOk(args) && parse.hasOption("wordlist")) {
                wordlist =  parse.getOptionValue("wordlist");
            }
            wordlist = parse.getOptionValue('w');
        } catch (ParseException parseException) {
            log.error("Couldn't parse provided wordlist value" + parseException.getMessage());
            System.exit(1);
        }
        return wordlist;
    }

    private boolean hasVerboseOption(String[] args) {
        boolean verbose = false;
        try {
            CommandLine parse = commandLineParser.parse(options, args);
            if (isOptionsOk(args)) {
                verbose = parse.hasOption('v');
            }
            verbose = parse.hasOption("verbose");
        } catch (ParseException parseException) {
            log.error("Couldn't parse provided verbose" + parseException.getMessage());
            System.exit(1);
        }
        return verbose;
    }

    private boolean isOptionsOk(String[] args) throws ParseException {
        if (isOptionsParses(args) && isOptionsValid(args)){
            return true;
        }
        throw new ParseException(" ");
    }
}