package com.exploitable.javahashcodebreaker;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.RandomAccessFile;
import java.util.Random;

@SpringBootTest
class JavaHashcodeBreakerApplicationTests {

    private final static File rockyouFile = new File("src/test/java/com/exploitable/javahashcodebreaker/rockyousmall-3000.txt");

    @Autowired
    private HashCrackService hashCrackService;

    @Test
    @Order(1)
    void contextLoads() {
    }

    /**
     * About test algorithm.
     * We start reading random byte from small copy of popular file for dictionary attack,
     * with {@link  RandomAccessFile} moving pointer in another place and read to the end of the current line.
     * Then, reading next line again to get the full word, calculate the hash and start main service with possible hash.
     * Main service starts cracking and prints in standard output result. Test parses console and compare hashes and words.
     * This is implementation of <a href="https://en.wikipedia.org/wiki/Rejection_sampling">Rejection sampling</a>.
     */
    @Test
    @Order(2)
    public void randomHashCrack() {
        try (RandomAccessFile randomAccess = new RandomAccessFile(rockyouFile, "r")) {
            long fileLength = rockyouFile.length();
            Random random = new Random();
            int randomPosition = random.nextInt((int) (fileLength - 1));
            randomAccess.seek(randomPosition);
//          sometimes pointer points to the single char in the middle of the word. that's why we need to read line twice
            String l = randomAccess.readLine();
            String line = randomAccess.readLine();
            int possibleHash = line.hashCode();
            ByteArrayOutputStream console = new ByteArrayOutputStream();
            System.setOut(new PrintStream(console));
            hashCrackService.crackTheHash(new String[]{"-h", String.valueOf(possibleHash), "-w", String.valueOf(rockyouFile)});
            String[] split = console.toString().split("\u001B\\[32m");
            String[] expectHashArr = split[1].split("\u001B\\[0m");
            String s = expectHashArr[0].trim();
            int expectedHash = s.hashCode();

            Assertions.assertEquals(possibleHash, expectedHash);
            Assertions.assertEquals(line, s);
        } catch (IOException e) {
            Assertions.fail(e.getMessage());
        }
    }
}
