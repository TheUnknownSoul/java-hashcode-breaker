package com.exploitable.javahashcodebreaker;


import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.boot.test.system.CapturedOutput;
import org.springframework.boot.test.system.OutputCaptureExtension;


import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Random;

class JavaHashcodeBreakerApplicationTests {

    private final static File rockyouFile = new File("src/test/java/com/exploitable/javahashcodebreaker/rockyousmall-3000.txt");

    private static HashCrackService hashCrackService;

    @BeforeAll
    public static void initService(){
        CommandLineParser commandLineParser = new DefaultParser();
        HelpFormatter helpFormatter = new HelpFormatter();
        Option wordlistOption = new Option("w", "wordlist", true, "Provide wordlist for dictionary attack");
        Option hashOption = new Option("h", "hash", true, "Add the hash in double quotes \"\" ");
        Option verboseOption = new Option("v", "verbose", false, " Set verbose output");
        Option helpOption = new Option("help","help", false,"Print supported options");
        Options options = new Options();
        options.addOption(wordlistOption);
        options.addOption(hashOption);
        options.addOption(verboseOption);
        options.addOption(helpOption);
        hashCrackService = new HashCrackService(options, commandLineParser,  helpFormatter);
    }


    /**
     * About test algorithm.
     * We start reading random byte from small copy of popular file for dictionary attack,
     * with {@link  RandomAccessFile} moving pointer in another place and read to the end of the current line.
     * Then, reading next line again to get the full word, calculate the hash and start main service with possible hash.
     * Main service starts cracking and prints in standard output result. Test parses console and compare hashes and words.
     * This is implementation of <a href="https://en.wikipedia.org/wiki/Rejection_sampling">Rejection sampling</a>.
     */
    @Test
    @ExtendWith(OutputCaptureExtension.class)
    public void randomHashCrack(CapturedOutput output) {
        try (RandomAccessFile randomAccess = new RandomAccessFile(rockyouFile, "r")) {
            long fileLength = rockyouFile.length();
            Random random = new Random();
            int randomPosition = random.nextInt((int) (fileLength - 1));
            randomAccess.seek(randomPosition);
//          sometimes pointer points to the single char in the middle of the word. that's why we need to read line twice
            String l = randomAccess.readLine();
            String line = randomAccess.readLine();
            int possibleHash = line.hashCode();
            hashCrackService.crackTheHash(new String[]{"-h", String.valueOf(possibleHash), "-w", String.valueOf(rockyouFile)});
            String console = output.getOut();
            String[] split = console.split("\u001B\\[32m");
            String[] expectHashArr = split[1].split("\u001B\\[0m");
            String s = expectHashArr[0].trim();
            int expectedHash = s.hashCode();

            Assertions.assertEquals(possibleHash, expectedHash);
            Assertions.assertEquals(line, s);
        } catch (IOException e) {
            Assertions.fail(e.getMessage());
        }
    }
}
